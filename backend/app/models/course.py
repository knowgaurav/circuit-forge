"""Course and level Pydantic models for LLM Course Generator."""

from datetime import datetime
from enum import Enum
from typing import Any

from pydantic import BaseModel, Field


class Difficulty(str, Enum):
    """Course difficulty level."""

    BEGINNER = "Beginner"
    INTERMEDIATE = "Intermediate"
    ADVANCED = "Advanced"


class GenerationState(str, Enum):
    """Level content generation state."""

    NOT_QUEUED = "not_queued"
    QUEUED_PRIORITY = "queued_priority"
    QUEUED_BACKGROUND = "queued_background"
    GENERATING = "generating"
    GENERATED = "generated"
    FAILED = "failed"


class LevelStatus(str, Enum):
    """Student's progress status on a level."""

    NOT_STARTED = "not_started"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    SKIPPED = "skipped"


# --- Course Plan Models ---


class LevelOutline(BaseModel):
    """Brief outline of a level (part of course plan)."""

    level_number: int = Field(alias="levelNumber", ge=1)
    title: str = Field(min_length=1, max_length=100)
    description: str = Field(min_length=1, max_length=500)

    model_config = {"populate_by_name": True}


class CoursePlan(BaseModel):
    """Complete course plan generated by LLM."""

    id: str | None = None
    topic: str = Field(min_length=1, max_length=200)
    title: str = Field(min_length=1, max_length=200)
    description: str = Field(min_length=1, max_length=2000)
    difficulty: Difficulty
    estimated_hours: float = Field(alias="estimatedHours", ge=1, le=100)
    levels: list[LevelOutline] = Field(min_length=8, max_length=20)
    created_at: datetime = Field(default_factory=datetime.utcnow, alias="createdAt")
    creator_participant_id: str | None = Field(
        default=None, alias="creatorParticipantId"
    )

    model_config = {"populate_by_name": True}


# --- Level Content Models ---


class KeyTerm(BaseModel):
    """A key term with definition."""

    term: str
    definition: str


class TheorySection(BaseModel):
    """Theory section of a level."""

    objectives: list[str] = Field(min_length=2, max_length=5)
    concept_explanation: str = Field(alias="conceptExplanation", min_length=100)
    real_world_examples: list[str] = Field(
        alias="realWorldExamples", min_length=1, max_length=5
    )
    key_terms: list[KeyTerm] = Field(alias="keyTerms", default_factory=list)

    model_config = {"populate_by_name": True}


class ComponentSpec(BaseModel):
    """Component specification for practical section."""

    type: str  # Must match CircuitForge ComponentType
    count: int = Field(ge=1)
    properties: dict[str, Any] = Field(default_factory=dict)


class BuildStep(BaseModel):
    """A single build step in practical section."""

    step_number: int = Field(alias="stepNumber", ge=1)
    instruction: str = Field(min_length=10)
    hint: str | None = None

    model_config = {"populate_by_name": True}


class RequiredComponent(BaseModel):
    """Required component for validation."""

    type: str
    min_count: int = Field(alias="minCount", ge=1)

    model_config = {"populate_by_name": True}


class RequiredConnection(BaseModel):
    """Required connection for validation."""

    from_spec: str = Field(alias="from")  # e.g., "SWITCH_TOGGLE:0:output"
    to_spec: str = Field(alias="to")  # e.g., "LED_RED:0:input"

    model_config = {"populate_by_name": True}


class ValidationCriteria(BaseModel):
    """Criteria for validating student's circuit."""

    required_components: list[RequiredComponent] = Field(
        alias="requiredComponents", default_factory=list
    )
    required_connections: list[RequiredConnection] = Field(
        alias="requiredConnections", default_factory=list
    )

    model_config = {"populate_by_name": True}


# --- Circuit Blueprint Models ---


class Position(BaseModel):
    """Position on the canvas."""

    x: float
    y: float


class BlueprintComponent(BaseModel):
    """A component in the circuit blueprint."""

    type: str  # Must match CircuitForge ComponentType
    label: str  # e.g., "AND1", "LED1"
    position: Position
    properties: dict[str, Any] = Field(default_factory=dict)

    model_config = {"populate_by_name": True}


class BlueprintWire(BaseModel):
    """A wire connection in the circuit blueprint."""

    from_spec: str = Field(alias="from")  # e.g., "AND1:Y" (label:pinName)
    to_spec: str = Field(alias="to")  # e.g., "LED1:A"

    model_config = {"populate_by_name": True}


class CircuitBlueprint(BaseModel):
    """Complete circuit blueprint that can be loaded onto the canvas."""

    components: list[BlueprintComponent] = Field(default_factory=list)
    wires: list[BlueprintWire] = Field(default_factory=list)

    model_config = {"populate_by_name": True}


class PracticalSection(BaseModel):
    """Practical section of a level."""

    components_needed: list[ComponentSpec] = Field(alias="componentsNeeded")
    steps: list[BuildStep] = Field(min_length=1)
    expected_behavior: str = Field(alias="expectedBehavior", min_length=20)
    validation_criteria: ValidationCriteria = Field(alias="validationCriteria")
    common_mistakes: list[str] = Field(alias="commonMistakes", default_factory=list)
    circuit_blueprint: CircuitBlueprint | None = Field(
        default=None, alias="circuitBlueprint"
    )

    model_config = {"populate_by_name": True}


class LevelContent(BaseModel):
    """Complete content for a single level."""

    id: str | None = None
    course_plan_id: str = Field(alias="coursePlanId")
    level_number: int = Field(alias="levelNumber", ge=1)
    generation_state: GenerationState = Field(
        default=GenerationState.NOT_QUEUED, alias="generationState"
    )
    celery_task_id: str | None = Field(default=None, alias="celeryTaskId")

    # Content (populated when generated)
    theory: TheorySection | None = None
    practical: PracticalSection | None = None

    generated_at: datetime | None = Field(default=None, alias="generatedAt")
    token_usage: int | None = Field(default=None, alias="tokenUsage")
    error_message: str | None = Field(default=None, alias="errorMessage")

    model_config = {"populate_by_name": True}


# --- Progress Models ---


class CourseEnrollment(BaseModel):
    """Student enrollment in a course."""

    id: str | None = None
    participant_id: str = Field(alias="participantId")
    course_plan_id: str = Field(alias="coursePlanId")
    current_level: int = Field(default=1, alias="currentLevel", ge=1)
    started_at: datetime = Field(default_factory=datetime.utcnow, alias="startedAt")
    last_activity_at: datetime = Field(
        default_factory=datetime.utcnow, alias="lastActivityAt"
    )

    model_config = {"populate_by_name": True}


class LevelProgress(BaseModel):
    """Student's progress on a specific level."""

    id: str | None = None
    enrollment_id: str = Field(alias="enrollmentId")
    level_number: int = Field(alias="levelNumber", ge=1)
    status: LevelStatus = LevelStatus.NOT_STARTED
    circuit_snapshot: dict[str, Any] | None = Field(
        default=None, alias="circuitSnapshot"
    )
    time_spent_seconds: int = Field(default=0, alias="timeSpentSeconds", ge=0)
    validation_attempts: int = Field(default=0, alias="validationAttempts", ge=0)
    completed_at: datetime | None = Field(default=None, alias="completedAt")

    model_config = {"populate_by_name": True}


# --- API Request/Response Models ---


class LLMConfig(BaseModel):
    """LLM configuration for API requests."""

    provider: str = Field(description="LLM provider ID (e.g., 'openai', 'anthropic', 'local')")
    api_key: str = Field(default="", alias="apiKey", description="User's API key (not required for local)")
    model: str = Field(description="Model to use")
    temperature: float = Field(default=0.7, ge=0, le=2)
    max_tokens: int = Field(default=4000, alias="maxTokens", ge=100, le=32000)
    # Local LLM specific fields
    base_url: str | None = Field(default=None, alias="baseUrl", description="Tunnel URL for local LLM")
    bridge_token: str | None = Field(default=None, alias="bridgeToken", description="Bridge token for local LLM")

    model_config = {"populate_by_name": True}


class GeneratePlanRequest(BaseModel):
    """Request to generate a course plan with user API key."""

    topic: str = Field(min_length=3, max_length=200)
    participant_id: str | None = Field(default=None, alias="participantId")

    # LLM Configuration (passed per-request, never stored)
    llm_config: LLMConfig = Field(alias="llmConfig")

    model_config = {"populate_by_name": True}


class TestConnectionRequest(BaseModel):
    """Request to test API key validity."""

    provider: str = Field(description="LLM provider ID")
    api_key: str = Field(alias="apiKey", min_length=10)
    model: str = Field(description="Model to test")

    model_config = {"populate_by_name": True}


class TestConnectionResponse(BaseModel):
    """Response for connection test."""

    success: bool
    message: str
    error: str | None = None
    token_usage: int | None = Field(default=None, alias="tokenUsage")

    model_config = {"populate_by_name": True}


class TopicSuggestion(BaseModel):
    """A suggested course topic."""

    topic: str
    title: str
    description: str
    difficulty: Difficulty
    estimated_levels: int = Field(alias="estimatedLevels")
    category: str

    model_config = {"populate_by_name": True}


class ValidationResult(BaseModel):
    """Result of circuit validation."""

    is_valid: bool = Field(alias="isValid")
    missing_components: list[str] = Field(alias="missingComponents", default_factory=list)
    missing_connections: list[str] = Field(
        alias="missingConnections", default_factory=list
    )
    feedback: str

    model_config = {"populate_by_name": True}
